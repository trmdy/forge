---
id: f-1e51
status: open
deps: []
links: []
created: 2026-01-11T17:51:03Z
type: feature
priority: 3
assignee: Tormod Haugland
parent: f-4c08
---
# Bridge forge msg and fmail DMs

## Problem

Currently Forge loops and fmail are separate systems:

- **forge msg**: Sends to loop queue (internal to Forge)
- **fmail send @loop**: Sends to DM inbox (fmail system)

This creates friction:
1. External agents using fmail can't easily communicate with loops
2. Loops can't receive work from the broader fmail ecosystem
3. Two mental models for "send message to agent"

## Solution

Unify by making loops consume their fmail DM inbox as part of the iteration lifecycle:

```
┌─────────────────────────────────────────────────────────┐
│                     Loop Iteration                       │
├─────────────────────────────────────────────────────────┤
│ 1. Check DM inbox (.fmail/dm/<loop-name>/)              │
│    → If messages, consume oldest as queue item          │
│ 2. Check queue (.forge/queues/<loop>/)                  │
│    → Process queue items as usual                       │
│ 3. Execute harness with effective prompt                │
└─────────────────────────────────────────────────────────┘
```

### Behavior

```bash
# These become equivalent ways to send work to a loop:
forge msg my-loop "please review auth.go"
fmail send @my-loop "please review auth.go"

# External agent can send via fmail:
export FMAIL_AGENT=architect
fmail send @coder-loop "implement JWT refresh"
# Loop picks this up on next iteration
```

## Implementation Notes

### Loop Engine Changes (internal/loop/engine.go)

```go
func (l *Loop) runIteration() error {
    // 1. Check fmail DM inbox first
    dmMsgs := l.consumeDMInbox()
    for _, dm := range dmMsgs {
        // Convert fmail message to queue item
        item := QueueItem{
            Type:      QueueItemMessage,
            Content:   dm.Body,
            Source:    "fmail:" + dm.ID,
            From:      dm.From,
            Priority:  mapPriority(dm.Priority),
            CreatedAt: dm.Time,
        }
        l.queue.Prepend(item)  // DMs get priority
    }
    
    // 2. Process queue as usual
    // ... existing queue processing ...
}

func (l *Loop) consumeDMInbox() []mail.Message {
    store := mail.NewStore(l.repoRoot)
    inbox := store.DMDir(l.name)
    
    msgs, _ := store.ListDMs(l.name, time.Time{})
    
    // Mark as consumed (delete or move to processed/)
    for _, msg := range msgs {
        store.ArchiveDM(l.name, msg.ID)
    }
    
    return msgs
}
```

### forge msg Changes (cmd/forge/msg.go)

Option A: `forge msg` writes to fmail DM:
```go
func sendMessage(loop, message string) error {
    // Write to .fmail/dm/<loop>/ instead of queue
    store := mail.NewStore(repoRoot)
    msg := mail.Message{
        From: "forge-cli",
        To:   "@" + loop,
        Body: message,
    }
    return store.SendDM(loop, msg)
}
```

Option B: Keep both paths, let user choose:
```bash
forge msg my-loop "text"           # Direct to queue (fast, internal)
forge msg my-loop --via-fmail "text"  # Via fmail DM (traceable, external)
```

Recommend **Option A** for simplicity - unify on fmail as the message transport.

### DM Processing Order

DMs are processed in chronological order (by message ID). If multiple DMs pending:
1. Sort by ID (oldest first)
2. Convert all to queue items
3. Prepend to queue (so they're processed before existing items)

### Archive vs Delete

After consuming a DM, don't delete immediately - archive to `.fmail/dm/<loop>/processed/`:
```
.fmail/dm/my-loop/
├── 20260111-153000-0001.json        # Pending
├── 20260111-154000-0002.json        # Pending
└── processed/
    └── 20260111-150000-0001.json    # Already consumed
```

This enables:
- Debugging: See what was processed
- Replay: Move back to inbox to reprocess
- Audit: Track all messages to loop

### FMAIL_AGENT for Loops

When forge starts a loop, set `FMAIL_AGENT=<loop-name>`:
```go
func (l *Loop) start() {
    os.Setenv("FMAIL_AGENT", l.name)
    // Loop can now use fmail commands with correct identity
}
```

## Acceptance Criteria

- [ ] Loops check `.fmail/dm/<name>/` at start of each iteration
- [ ] DM messages converted to queue items and processed
- [ ] `forge msg <loop>` writes to fmail DM (or option to do so)
- [ ] Processed DMs archived (not deleted)
- [ ] `FMAIL_AGENT` set to loop name when loop starts
- [ ] External agents can send work via `fmail send @<loop>`
- [ ] Priority from fmail message respected (see f-ab22)

## Why This Matters

Enables:
- **Unified messaging**: One way to talk to agents (fmail)
- **External coordination**: Architect agent can assign work to loops via fmail
- **Traceability**: All messages go through fmail, visible in logs
- **Ecosystem integration**: Loops become first-class fmail citizens

## Related

- f-ab22: Priority mapping (DM priority affects queue position)
- f-b3a1: Ledger traceability (store fmail msg ID in ledger)
- f-89ec: Loop events (loops can emit status to fmail topics)
