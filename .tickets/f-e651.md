---
id: f-e651
status: open
deps: [f-de22]
links: []
created: 2026-01-11T17:50:50Z
type: feature
priority: 3
assignee: Tormod Haugland
parent: f-3a50
---
# backlog_done marker in protocol

## Problem

When a client connects with `--after <id>` or `--since <timestamp>`, forged replays historical messages before streaming live ones. The client has no way to distinguish:

1. **Historical messages**: Replayed from disk, already happened
2. **Live messages**: Arriving in real-time

This matters for:
- **TUI**: May want to render historical messages differently (dimmed, collapsed)
- **Automation**: May want to process backlog in batch, then switch to event-driven
- **Progress indicators**: Can show "catching up..." then "live"

## Solution

After replaying historical messages, emit a `backlog_done` event before streaming live:

```json
{"msg": {"id": "20260111-150000-0001", ...}}
{"msg": {"id": "20260111-150500-0002", ...}}
{"msg": {"id": "20260111-151000-0003", ...}}
{"event": "backlog_done", "last_id": "20260111-151000-0003", "count": 3}
{"msg": {"id": "20260111-153000-0004", ...}}  // Live from here
```

## Implementation Notes

### Protocol Changes (PROTOCOL.md)

Add event type documentation:

```markdown
### Events

In addition to messages, the server may emit events:

#### backlog_done

Emitted after historical replay completes, before live streaming begins.

```json
{
  "event": "backlog_done",
  "last_id": "20260111-151000-0003",
  "count": 3
}
```

| Field | Description |
|-------|-------------|
| `last_id` | ID of last replayed message (empty if no backlog) |
| `count` | Number of messages replayed |
```

### Forged Changes (internal/daemon/mail_server.go)

```go
func (s *MailServer) handleWatch(conn net.Conn, req WatchRequest) {
    // Replay historical messages
    var lastID string
    var count int
    
    if req.After != "" {
        msgs, _ := s.store.ListMessagesAfter(req.Topic, req.After)
        for _, msg := range msgs {
            s.sendMessage(conn, msg)
            lastID = msg.ID
            count++
        }
    }
    
    // Emit backlog_done marker
    s.sendEvent(conn, Event{
        Type:   "backlog_done",
        LastID: lastID,
        Count:  count,
    })
    
    // Switch to live streaming
    s.streamLive(conn, req.Topic)
}
```

### Client Handling (cmd/fmail/watch.go)

```go
for {
    line, _ := reader.ReadBytes('\n')
    var envelope struct {
        Msg   *Message `json:"msg,omitempty"`
        Event string   `json:"event,omitempty"`
    }
    json.Unmarshal(line, &envelope)
    
    if envelope.Event == "backlog_done" {
        // Optional: notify user
        if !jsonOutput {
            fmt.Fprintf(os.Stderr, "-- caught up, streaming live --\n")
        }
        continue
    }
    
    if envelope.Msg != nil {
        printMessage(envelope.Msg)
    }
}
```

### Standalone Mode

In standalone polling mode, there's no clear backlog/live distinction. Options:
1. **Skip marker**: Polling is always "live" conceptually
2. **Emit once**: After first poll returns results, emit marker

Recommend option 1 for simplicity - marker only makes sense in connected mode.

## Acceptance Criteria

- [ ] Forged emits `backlog_done` after replay, before live stream
- [ ] Event includes `last_id` and `count` fields
- [ ] `fmail watch --json` passes through the event
- [ ] Human output optionally shows "caught up" indicator
- [ ] PROTOCOL.md documents the event
- [ ] Works correctly when no backlog (count=0, last_id empty)

## Why This Matters

Enables:
- **TUI state**: Show "replaying..." then "live" status
- **Batch processing**: Collect backlog, process in batch, then handle live one-by-one
- **Debugging**: Know when you're seeing history vs real-time

## Dependencies

- f-de22: Cursor resume (`--after`) must exist for replay logic

## Related

- f-de22: Provides the replay mechanism this builds on
- TUI inbox panel will use this for status indication
