---
id: f-1240
status: open
deps: []
links: []
created: 2026-01-11T17:51:16Z
type: feature
priority: 4
assignee: Tormod Haugland
---
# fmail reply shorthand command

## Problem

Replying to a message requires verbose syntax:

```bash
# See a message
$ fmail log task
20260111-153000-0001  architect  please review auth.go

# Reply requires knowing the target and message ID
$ fmail send @architect --reply-to 20260111-153000-0001 "on it, will review now"
```

This is:
1. **Error-prone**: Easy to forget `--reply-to` or mistype the ID
2. **Tedious**: Copy-paste the message ID
3. **Not discoverable**: New users don't know about `--reply-to`

## Solution

Add `fmail reply` command that handles the boilerplate:

```bash
fmail reply 20260111-153000-0001 "on it, will review now"
```

This automatically:
1. Looks up the original message
2. Determines the reply target (original sender or topic)
3. Sets `--reply-to` to the message ID

### Behavior

```bash
# Reply to topic message → sends to same topic
$ fmail log task
20260111-153000-0001  architect -> task  "please review auth.go"
$ fmail reply 20260111-153000-0001 "on it"
# Equivalent to: fmail send task --reply-to 20260111-153000-0001 "on it"

# Reply to DM → sends to original sender
$ fmail log @myname
20260111-153000-0001  architect -> @myname  "can you help?"
$ fmail reply 20260111-153000-0001 "sure, what do you need?"
# Equivalent to: fmail send @architect --reply-to 20260111-153000-0001 "sure..."
```

### Options

```bash
fmail reply <msg-id> <message>
fmail reply <msg-id> -f <file>
echo "response" | fmail reply <msg-id>

# Override target (reply to sender instead of topic)
fmail reply 20260111-153000-0001 --to-sender "thanks architect"

# Reply to different target
fmail reply 20260111-153000-0001 --to @someone-else "FYI"
```

## Implementation Notes

### Command Structure (cmd/fmail/reply.go)

```go
var replyCmd = &cli.Command{
    Name:      "reply",
    Usage:     "Reply to a message",
    ArgsUsage: "<msg-id> <message>",
    Flags: []cli.Flag{
        &cli.StringFlag{Name: "to", Usage: "Override reply target"},
        &cli.BoolFlag{Name: "to-sender", Usage: "Reply to sender instead of topic"},
        &cli.StringFlag{Name: "file, f", Usage: "Read message from file"},
    },
    Action: func(c *cli.Context) error {
        msgID := c.Args().Get(0)
        body := c.Args().Get(1)
        
        if body == "" && c.String("file") != "" {
            body = readFile(c.String("file"))
        }
        
        // Find original message
        original, err := store.FindMessage(msgID)
        if err != nil {
            return fmt.Errorf("message not found: %s", msgID)
        }
        
        // Determine reply target
        target := determineReplyTarget(original, c)
        
        // Send reply
        msg := Message{
            From:    agentName,
            To:      target,
            Body:    body,
            ReplyTo: msgID,
        }
        
        return store.Send(target, msg)
    },
}

func determineReplyTarget(original Message, c *cli.Context) string {
    if c.String("to") != "" {
        return c.String("to")
    }
    if c.Bool("to-sender") {
        return "@" + original.From
    }
    
    // Default: reply to same destination
    if strings.HasPrefix(original.To, "@") {
        // DM: reply to sender
        return "@" + original.From
    }
    // Topic: reply to same topic
    return original.To
}
```

### Message Lookup (internal/mail/store.go)

```go
func (s *Store) FindMessage(id string) (*Message, error) {
    // Search topics
    for _, topic := range s.ListTopics() {
        if msg, err := s.ReadMessage(topic, id); err == nil {
            return msg, nil
        }
    }
    
    // Search DM inboxes
    for _, dm := range s.ListDMInboxes() {
        if msg, err := s.ReadDM(dm, id); err == nil {
            return msg, nil
        }
    }
    
    return nil, ErrNotFound
}
```

### Short ID Support

Allow partial ID matching for convenience:

```bash
fmail reply 153000-0001 "response"  # Matches if unique
fmail reply 0001 "response"          # Error if ambiguous
```

```go
func (s *Store) FindMessageByPartialID(partial string) (*Message, error) {
    matches := s.searchByPartialID(partial)
    if len(matches) == 0 {
        return nil, ErrNotFound
    }
    if len(matches) > 1 {
        return nil, fmt.Errorf("ambiguous ID, matches: %v", matches)
    }
    return matches[0], nil
}
```

## Acceptance Criteria

- [ ] `fmail reply <id> "text"` sends reply with --reply-to set
- [ ] Topic messages: reply goes to same topic
- [ ] DM messages: reply goes to original sender
- [ ] `--to-sender` forces reply to sender
- [ ] `--to` overrides reply target
- [ ] `-f` flag reads from file
- [ ] Stdin input works
- [ ] Partial ID matching with ambiguity error
- [ ] Error if message not found

## Future Enhancements

- `fmail reply-all <id>` for broadcast messages (uses broadcast_to)
- `fmail thread <id>` shows full conversation thread
- Tab completion for recent message IDs

## Why This Matters

- **Lower friction**: Replying becomes natural
- **Fewer errors**: Can't forget --reply-to
- **Discoverability**: `fmail reply` is intuitive

## Related

- f-0c8c: Multi-recipient DM (reply-all builds on this)
- Existing --reply-to flag (this is sugar on top)
